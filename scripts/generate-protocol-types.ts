import * as path from 'path';
import * as fs from 'fs';
import * as puppeteer from '../lib';

const outputPath = path.join(__dirname, '../src/protocol.ts');

interface ProtocolSchema {
  id: string;
  domains: ProtocolSchema[];
  properties: ProtocolSchema[]
  name: string;
  optional?: boolean;
  description?: string;
  domain: string;
  $ref?: string;
  enum?: ProtocolSchema[];
  type?: string;
  items?: ProtocolSchema;
  types: ProtocolSchema[];
  events?: ProtocolSchema[];
  parameters?: ProtocolSchema[];
  commands?: ProtocolSchema[];
  returns?: ProtocolSchema[];
}

(async function generateProtocolTypes() {
  const browser = await puppeteer.launch({
    pipe: false,
    executablePath: process.env.BINARY,
  })
  const origin = browser.wsEndpoint().match(/ws:\/\/([0-9A-Za-z:\.]*)\//)![1];

  const page = await browser.newPage();
  await page.goto(`http://${origin}/json/protocol`);
  const json = JSON.parse(await page.evaluate(() => document.documentElement.innerText)) as ProtocolSchema;
  const version = await browser.version();
  await browser.close();
  const output = `// Auto-generated by /scripts/generate-protocol-types.ts

type binary = string;
export namespace Protocol {${json.domains.map(domain => `${domain.description ? `
  /**
   * ${domain.description}
   */` : ''}
  export namespace ${domain.domain} {${(domain.types || []).map(type => `${type.description ? `
      /**
       * ${type.description}
       */` : ''}${type.properties ? `
      export interface ${type.id} {${(type.properties || []).map(property => `${property.description ? `
          /**
           * ${property.description}
           */` : ''}
          ${property.name}${property.optional ? '?' : ''}: ${typeOfProperty(property)};`).join(``)}
      }` : `
      export type ${type.id} = ${typeOfProperty(type)};`}`).join('')}
      ${(domain.events || []).map(event => `${event.description ? `
      /**
       * ${event.description}
       */` : ''}${event.parameters ? `
      export type ${event.name}Payload = {${event.parameters.map(parameter => `${parameter.description ? `
          /**
           * ${parameter.description}
           */` : ''}
          ${parameter.name}${parameter.optional ? '?' : ''}: ${typeOfProperty(parameter)};`).join(``)}
      }` : `
      export type ${event.name}Payload = void;`}`).join('')}
      ${(domain.commands || []).map(command => `${command.description ? `
      /**
       * ${command.description}
       */` : ''}
      export type ${command.name}Parameters = {${(command.parameters || []).map(parameter => `${parameter.description ? `
          /**
           * ${parameter.description}
           */` : ''}
          ${parameter.name}${parameter.optional ? '?' : ''}: ${typeOfProperty(parameter)};`).join(``)}
      }
      export type ${command.name}ReturnValue = {${(command.returns || []).map(retVal => `${retVal.description ? `
          /**
           * ${retVal.description}
           */` : ''}
          ${retVal.name}${retVal.optional ? '?' : ''}: ${typeOfProperty(retVal)};`).join(``)}
      }`).join('')}
  }
  `).join('')}
  export interface Events {${json.domains.map(domain => (domain.events || []).map(event => `
    "${domain.domain}.${event.name}": ${domain.domain}.${event.name}Payload;`).join('')).join('')}
  }
  export interface CommandParameters {${json.domains.map(domain => (domain.commands || []).map(command => `
    "${domain.domain}.${command.name}": ${domain.domain}.${command.name}Parameters;`).join('')).join('')}
  }
  export interface CommandReturnValues {${json.domains.map(domain => (domain.commands || []).map(command => `
    "${domain.domain}.${command.name}": ${domain.domain}.${command.name}ReturnValue;`).join('')).join('')}
  }
}
`;

  fs.writeFileSync(outputPath, output);
  console.log(`Wrote protocol.ts for ${version} to ${path.relative(process.cwd(), outputPath)}`);
})().catch(reportErrorAndExit)

function typeOfProperty(property: ProtocolSchema, domain?: string): string | undefined {
  if (property.$ref) return property.$ref.includes('.') || !domain ? property.$ref : domain + '.' + property.$ref;
  if (property.enum) return property.enum.map(value => JSON.stringify(value)).join('|');
  switch (property.type) {
    case 'array':
      return typeOfProperty(property.items!, domain) + '[]';
    case 'integer':
      return 'number';
  }
  return property.type;
}

function reportErrorAndExit(e: Error): never {
  console.error(e);
  process.exit(1)
}